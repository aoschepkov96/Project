# Project
## Инструкция
### Перед началом работы необходимо:
1.	Установить Python (при создании была использована версия 3.7, однако более ранние версии должны подойти ( https://www.python.org/downloads/)
2.	Установить Anaconda (https://www.anaconda.com/download/). 
3.	Установить MySQL (https://dev.mysql.com/downloads/mysql/, при установке отметить галочкой установку MySQL Connector/ Python. Коннектор также можно установить в командной строке Anaconda *pip install MySQL-connector-python*
4.	Обновить команды pip до последней версии (через командную строку с помощью команды python -m pip install --upgrade pip)
5.	Обновить пакет pandas до последней версии (через командную строку с помощью команды pip install --upgrade pandas)
6. Создать пользователя и БД:
  + Открыть командную строку MySQL Command Line Client
  + Создать нового пользователя: CREATE USER project_user;
  + Создать новую БД: CREATE DATABASE project_db;
  + Предоставить пользователю привилегии на БД: GRANT ALL PRIVILEGES ON project_db.* TO project_user;
  + Обновить привилегии: FLUSH PRIVILEGES;
7.	Скачать папки «анкеты» и «контракты» по ссылке (https://drive.google.com/drive/folders/1VwgP8Vc_RCNAoZK5tWt6aUqdET6cS5vS)
8.	Создайте на своём компьютере папку, присвойте ей какое-либо название на английском языке (далее в инструкции **project_folder**) и создайте внутри этой папки ещё шесть папок с названиями: *contracts, applications, output_1, output_2, output_3, output_4*. В папку contracts распакуйте архив с данными по контрактам, а в папку applications распакуйте архив с данными по анкетам кредитных заявок. Важно, чтобы в папках contracts и applications не было никаких подпапок, а сразу находились только файлы с расширением .xlsx). Кроме указанных данных в папках contracts и applications не должно ничего находиться.
9.	Скачайте xls файл с данными по платежам (payments) и поместите в основную папку проекта там же где лежат скрипты и ipynb-тетрадки (project_folder) (https://drive.google.com/open?id=1VwgP8Vc_RCNAoZK5tWt6aUqdET6cS5vS)
10. **Открыть Anaconda Promt, написать *cd <ваш путь>* (например *cd C:\Users\User\Documents\Python Scripts\project_folder*), в котором лежат скрипты combo.py, part_1.py, part_2.py, part_3.py, part_4.py. Далее исполнить команду *python combo.py* и следовать инструкциям внутри консоли** 
# Блок 1. Автоматический импорт в базу данных неструктурированных данных
1.  *(Опционально)* Если Вы хотите запустить код (для наглядности) из Jupyter Notebook, то: 
   +	Скачайте тетрадку part_1.ipynb и поместите её в созданную вами папку project_folder (https://github.com/kalininiad/Project)
   +	Открыть part_1.ipynb с помощью Jupyter Notebook
   + В начале тетрадки замените переменные user (по умолчанию project_user) и database (по умолчанию project_db) в соответствии с созданной вами базой данных. Также замените переменную my_path в соответствии с путем, по которому расположена ваша общая папка проекта.
   +	Запустите весь код с помощью нажатия Cell -> Run All.
## Описание кода
1.	Сначала загружаются релевантные данные по анкетам в виде таблиц в Python: *ID заёмщика, доход, тип дохода, владение домом, возраст машины, количество детей,	количество человек в семье, дата рождения, семейное положение, пол, информация о работе, образование, дата заявки*. Поля в таблицы преобразуются для передачи их в базу данных; создается таблица applications в базе данных, заполняются данными из таблицы Python. 
2. Создаётся таблица контрактов в Python и передаётся в БД, загружая следующие характеристики: *ID заёмщика, сумма кредита, срок кредита, номер контракта, тип кредита, сумма аннуитетного платежа, дата контракта*. Таблица contracts, связанна с applications по полю id_number, поэтому в ходе выполнения скрипта не загружаются данные о контрактах, которых нет в БД applications. 
3.	Загружается таблица данных по платежам (из payments) и отправляется в базу данных со следующими полями: номер соответствующего контракта, дата платежа, задолженность на дату, сумма оплаченной задолженности. Таблица payments связана с таблицей contracts, то есть в БД не выгружаются данные по платежам тех контрактов, которых нет в БД contracts.
4. Данные проверены на возможные ошибки переменных:
 + отрицательные значения положительных по смыслу числовых переменных с заложенным исправлением
 + аномальные значения числовых переменных
 + ошибки в названиях категорий текстовых переменных с заложенным исправлением
 + ошибки в соотношении значений связанных по смыслу переменных (family, children)
 + ошибки в отображении дат с заложенным исправлением 
5. Признак age_of_car заменён на car_owned (т.е. 1 или 0), категория <undefined> в признаке employed_by заменена на пустое значение.
6. Текстовые поля кодируются числами, для расшифровки кодов созданы и переданы в базу данных словари. 
7. Пользователь имеет возможность выгрузить полученные в ходе исполнения кода таблицы в папку output_1 в формате csv.

# Блок 2. Анализ и предобработка данных
## Инструкция по запуску кода:
1. *(Опционально)* Если Вы хотите запустить код (для наглядности) из Jupyter Notebook, то: 
 + Поместите тетрадку part_2.ipynb в свою общую папку проекта.
 + В начале тетрадки замените переменные user (по умолчанию project_user) и database (по умолчанию project_db) в соответствии с созданной вами базой данных. Также замените переменную my_path в соответствии с путем, по которому расположена ваша общая папка проекта.
 + Запустите код (Cell -> run all).
## Описание кода:
Часть 1. Выявление событий дефолтов
1.	Определяются контракты, удовлетворяющие заданному пользователем горизонту риска, им присваивается флаг {0/1}, характеризующий наличие дефолта.
2.	 В базу данных отправляется соответствующая таблица.
3.	Строится таблица по заявкам, удовлетворяющим заданному пользователем горизонту риска, в которой к имеющимся в заявках данным добавляется флаг {дефолт/недефолт}.
Часть 2. Статистический анализ разделяющей способности переменных
1.	 Пользователю предлагается выбрать любую (категориальную или непрерывную переменную) из таблицы по заявкам, построенной в предыдущей части.
2.	По выбранной переменной строится таблица значений WOE и график (если переменная непрерывная, то предварительно производится разбиение на категории по квантилям).
3.	По выбранной переменной строится ROC-кривая.
4.	Для всех переменных строится график показателя IV.
## Результат выполнения кода:
1.	Создание в БД таблицы contracts_risk_horizon_{0}_months  по контрактам, удовлетворяющим горизонту риска, с данными о номере контракта, дате дефолта, наличии/отсутствии дефолта (флаг {1/0}).
2.	Экспорт в папку output_2 файла csv с данными по заявкам, удовлетворяющим заданному пользователем горизонту риска, в котором к имеющимся в заявках данным добавлен флаг {дефолт/недефолт}.
3.	Экспорт в папку output_2 файлов в формате png с графиками (WOE для выбранной пользователем переменной, IV для всех переменных, ROC-кривой для выбранной пользователем переменной).

# Блок 3. Присвоение рейтингового балла по переменным.

## Инструкция по запуску кода:
1. *(Опционально)* Если Вы хотите запустить код (для наглядности) из Jupyter Notebook, то: 
 + Поместите тетрадку part_3.ipynb в свою общую папку проекта.
 + В начале тетрадки замените переменные user (по умолчанию project_user) и database (по умолчанию project_db) в соответствии с созданной вами базой данных. Также замените переменную my_path в соответствии с путем, по которому расположена ваша общая папка проекта.
 + Запустите код (Cell -> run all).

## Описание кода:
Код разделен на несколько частей:
Основная часть (присвоение рейтинговых баллов):
1.	Загрузка данных 
•	Составляем таблицу по дефолтам (выгружаем из таблицы платежей номера контрактов, определяем имела ли место просрочка платежей более, чем на 90 дней, присваиваем индекс (1) для дефолтов).
•	Выводим таблицу с основными характеристиками клиентов с дефолтами
2.	Правила обработки информации
•	Каждой категории текстовых полей из таблицы заемщиков присваивается балл на основе показателя WOE.
•	Непрерывные переменные сначала группируются по 25% выборки.

3.	Присвоение рейтинговых баллов
•	Ранжируем категории в каждой переменной по возрастанию WOE
•	Самому низкому WOE назначается балл равный одному - далее по возрастанию WOE каждой категории добавляется 1 балл
•	Полученные таким образом баллы нормализуются к шкале от 1 до 100: максимальный балл в категории считается за 100%, остальные считаются как доля от максимального

4.	Выгрузка результата в формате .csv (два файла: таблица с баллами по всем контрактам и по дефолтам).


## Результат выполнения кода:
1.	Каждому столбцу характеристик присвоены баллы на основе показателя WOE.
2.	Баллы пронормированы и составлен рейтинг контрактов.
3.	Пользователь имеет возможность выгрузить данные, сформированные скриптом, в формате .csv.

# Блок 4. Определение совокупного рейтингового балла.

## Инструкция по запуску кода:
1. *(Опционально)* Если Вы хотите запустить код (для наглядности) из Jupyter Notebook, то: 
 + Поместите тетрадку part_4.ipynb в свою общую папку проекта.
 + В начале тетрадки замените переменные user (по умолчанию project_user) и database (по умолчанию project_db) в соответствии с созданной вами базой данных. Также замените переменную my_path в соответствии с путем, по которому расположена ваша общая папка проекта.
 + Запустите код (Cell -> run all).
 
 ## Описание кода:
 1. Данные на вход принимаются из файловой системы: таблица с присвоенными баллами от 1 до 100 и таблица с Information Value. 
 2. Каждому признаку заёмщика присваивается "предсказательная сила" на основе показателя Information Value: strong ( 0.3 < IV < 0.5), medium ( 0.1 < IV < 0.3), weak (0.02 < IV < 0.1), useless (IV < 0.02), suspicious (IV > 0.5) на основе Informtaion Value.
 3. На основе предсказательной силы каждой переменной присваивается вес по следующему правилу: пользователь задаёт вес для переменной strong в диапазоне от (strong_min до 1; strong_min высчитывается автоматически и показан пользователю), остальные веса пересчитываются так, что они распределены как strong > medium > weak > useless > suspicious.
 4. Совокупный рейтинговый балл для заёмщика вычисляется как балл по признаку умноженный на вес признака.
 5. Строится ROC- кривая для совокупного рейтингового балла и вычисляется коэффициент Gini
 
## Результат выполнения кода:
1. Каждому признаку присвоен вес для подсчёта совокупного рейтингового балла.
2. для каждого заёмщика вычислен совокупный рейтинговый балл.
3. Построена ROC - кривая для совокупного рейтингового балла.
4. Пользователь имеет возможность выгрузить итоговую таблицу (ID заёмщика, умноженные на веса баллы по каждому призанку, совокупный рейтинговый балл); график для ROC-кривой

